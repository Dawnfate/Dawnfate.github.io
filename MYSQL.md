



`InnoDB` 通过 `MVCC` 和 `NEXT-KEY Locks`，解决了在`可重复读`的事务隔离级别下出现`幻读`的问题。

幻读是插入和删除数据时产生的数据一致性问题，可重复读是解决更新数据产生的问题。而一般情况下只有串行化才能解决幻读问题。

>  行锁在 InnoDB 中是基于`索引`实现的，所以一旦某个加锁操作没有使用索引，那么该锁就会退化为`表锁`。



### 三种行锁

### 记录锁

记录锁是某行记录进行上锁

```sql
--id列为主键列或唯一索引列
SELECT FROM table WHERE id = 1 FOR UPDATE;
--更新操作也能对数据加记录锁
UPDATE SET age = 50 WHERE id = 1;
```

这时id为1的记录行就会被锁住

因为InoDB是通过索引进行行锁操作的，所以id列必须是唯一索引

同时查询语句必须为`精准匹配`（`=`），不能为 `>`、`<`、`like`等，否则也会退化成`临键锁`



### 间隙锁

**间隙锁**基于`非唯一索引`，它`锁定一段范围内的索引记录`。**间隙锁**基于下面将会提到的`Next-Key Locking` 算法，请务必牢记：**使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据**。间隙锁是基于临建锁实现的。

```sql
--非唯一索引的范围查找时候触发
SELECT * FROM table WHERE id BETWEN 1 AND 10 FOR UPDATE;
```

即所有在`（1，10）`区间内的记录行都会被锁住，所有id 为 2、3、4、5、6、7、8、9 的数据行的插入会被阻塞，但是 1 和 10 两条记录行并不会被锁住。



### 临键锁（Next-Key Locks）

Next-Key 可以理解为一种特殊的**间隙锁**，也可以理解为一种特殊的**算法**。通过**临建锁**可以解决`幻读`的问题。 每个数据行上的`非唯一索引列`上都会存在一把**临键锁**，当某个事务持有该数据行的**临键锁**时，会锁住一段**左开右闭区间**的数据。需要强调的一点是，`InnoDB` 中`行级锁`是基于索引实现的，**临键锁**只与`非唯一索引列`有关，在`唯一索引列`（包括`主键列`）上不存在**临键锁**。

临建锁是把每个索引之间的元素进行上锁，这里就阻止了delete和insert操作。


| id   | age  | name |
| ---- | ---- | ---- |
| 1    | 5    | Tom  |
| 2    | 10   | Lee  |
| 3    | 25   | Dawn |

该age列潜在的临建锁有(-∞, 5], (5,10], (10,25],(25,+∞]

例子：

事务A：

```sql
-- 根据非唯一索引列 UPDATE 某条记录 
UPDATE table SET name = Vladimir WHERE age = 24; 
-- 或根据非唯一索引列 锁住某条记录 
SELECT * FROM table WHERE age = 24 FOR UPDATE;
```


事务B：

```sql
INSERT INTO table VALUES (100, 26, 'Ezreal');
```

这时事务B就会因为事务A已经获得了临建锁而不得不进行阻塞操作。

