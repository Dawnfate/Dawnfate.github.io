

## 动态规划概要

动态规划问题的一般形式就是求**最值**

动态规划其实是运筹学的一种最优化方法，使用了数学归纳法

比如：f(n) =max(f(n - 1) + n, f(n) + m) 

动态规划的核心问题是穷举,穷举的过程中存在有重叠子问题，这时候就必须通过备忘录的方式来去优化穷举过程，避免重复计算;动态规划问题一定具备最优子结构，即每个子问题的最优解一定是整个问题的最优解

针对每个问题，需要列出正确的状态转移方程，才能正确穷举

动态规划三要素：

- 重叠子问题

- 最优子结构

- 状态转移方程

**明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义**



```
# 初始化 base case
dp[0][0][...] = base
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```

列出状态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。



## 解题：以力扣第三百题为例

[300. 最长递增子序列 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

求最长公共子序列

假设dp[0...i]都已经计算出来了，那么dp[i + 1]怎么计算

**`dp[i]` 表示以 `nums[i]` 这个数结尾的最长递增子序列的长度**。

base case  dp[i]很明显是自己本身，所以初始值为1

那么dp[i + 1] 就通过判断nums[i + 1] 是否大于nums[i],如果大于dp[0...i] + 1得到一个res，不断比较res, 最终选择最大的。

遇到一个问题是这个

```java
for (int j = 0; j < i; j++) {
    if (nums[i] > nums[j]) 
        dp[i] = Math.max(dp[i], dp[j] + 1);
}

```

遇到所有问题是这个

```java
for (int i = 0; i < nums.length; i++) {
    for (int j = 0; j < i; j++) {
        if (nums[i] > nums[j]) 
            dp[i] = Math.max(dp[i], dp[j] + 1);
    }
}

```

完整代码（加上dp）

```java
int lengthOfLIS(int[] nums) {
    // 定义：dp[i] 表示以 nums[i] 这个数结尾的最长递增子序列的长度
    int[] dp = new int[nums.length];
    // base case：dp 数组全都初始化为 1
    Arrays.fill(dp, 1);
    for (int i = 0; i < nums.length; i++) {
        for (int j = 0; j < i; j++) {
            if (nums[i] > nums[j]) 
                dp[i] = Math.max(dp[i], dp[j] + 1);
        }
    }
    
    int res = 0;
    for (int i = 0; i < dp.length; i++) {
        res = Math.max(res, dp[i]);
    }
    return res;
}

```

所以具体来讲，

首先要明确dp数组的定义，

然后根据dp数组的定义，运用数学归纳法，假设dp[0...i-1]都已经完成，怎么够到达dp[i],这一步的解决问题就基本解决，

但是如果不能解决，那就要考虑dp的升维

### dp数组遍历的方向

dp数组遍历的方向要看dp的base case，如何指向最终的想要的dp，这个方向就是遍历dp的方向。

**1、遍历的过程中，所需的状态必须是已经计算出来的**。

**2、遍历结束后，存储结果的那个位置必须已经被计算出来**。



看重叠子问题就画递归树，看一下有没有需要重复求的函数



### base case和备忘录的初始值是如何定义的

base case是根据设定的dp来决定的

备忘录的初始值一定要和合法的答案进行区分，原因是可以后续判断的时候无误的确认这是遍历过的答案，这里可以查看题目中的数组范围从而计算出对应的区间。

### 对动态规划的状态转移方程进行降维

降维的操作要么是高纬变低维，要么是使用二进制数对空间进行压缩（状态压缩）。