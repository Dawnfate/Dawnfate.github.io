JVM如何处理垃圾

哪些对象可以是垃圾

在java中对应有强软弱虚引用，强引用即使内存空间不足，也不会把对象回收，这就有可能造成OOM；软引用，当堆空间不足时就会触发垃圾回收；弱引用，只要发现了这个对象就有可能被回收；虚引用，如同虚设，任何时间都可能被回收；



怎么去辨别垃圾

在java1.2时使用的还是程序计数器的方式进行垃圾的判断，当存在有对象之间的引用的时候，我们就不回收垃圾，但是如果对象与对象之间存在循环引用的关系，那么即使对象为null也不会被回收。

以后的jdk版本中，使用了可达性分析来进行对对象是否应该回收的判断，只要对象不能达到GCRoot，那么久判断这个对象应该被回收。

GCRoot可以是那些对象

1.Java虚拟机栈（局部变量表 也就是方法中参数和方法局部变量）引用的对象。

2.方法区中（类信息）静态引用（也就是当前类静态引用）的对象。

3.处于存活状态的线程对象（注意是线程对象 而不是线程的对象）。

4.本地native方法jni引用的对象。



辨别垃圾之后对垃圾进行清除

清除的算法可以是标记清除算法、复制算法、标记整理算法。

`标记清除算法`（Mark-Sweep）是最基础的一种垃圾回收算法，它分为2部分，先把内存区域中的这些对象进行标记，哪些属于可回收标记出来，然后把这些垃圾拎出来清理掉。清理掉的垃圾就变成未使用的内存区域，等待被再次使用。但它存在一个很大的问题，那就是内存碎片。这里就会导致内存不能够有效利用，因为及其可能导致内存空间不连续而无法装入整个对象。

`复制算法`（Copying）是在标记清除算法基础上演化而来，解决标记清除算法的内存碎片问题。它将可用内存按容量划分为大小相等的两块，当需要进行垃圾回收时就会将使用的对象往另外一半空间进行迁移，然后把使用过的空间进行全部清除。保证了内存的连续可用，内存分配时也就不用考虑内存碎片等复杂情况。复制算法暴露了另一个问题，例如硬盘本来有500G，但却只能用200G，代价实在太高。

分代整理

`标记-压缩`算法标记过程仍然与标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，再清理掉端边界以外的内存区域。但是这里涉及到频繁的内存迁移问题。

以上的垃圾清除算法各有问题，所以才引入了分代思想，在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。

在老年代中，因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记-清理算法或者标记-整理算法来进行回收。

- 堆内存被划分为`两块`，一块的`年轻代`，另一块是`老年代`。

- 年轻代又分为`Eden`和`survivor`。他俩空间大小比例默认为8:2,

- 幸存区又分为`s0`和`s1`。这两个空间大小是一模一样的，就是一对双胞胎，他俩是1:1的比例

什么时候进行清除？

