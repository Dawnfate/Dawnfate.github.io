### 运算符



运算符顺序

单目> 双目 > 三目

这里是不知道到底是a移动b位还是b移动a位

**<<左移：相当于乘法。**a << b = a * (2^b)

**>>右移：相当于除法。**a >> b = a / (2 ^ b)



&（与运算）、|（或运算）、^（异或运算)

执行的顺序并不是从左往右执行的，而是因为[逻辑与](https://so.csdn.net/so/search?q=逻辑与&spm=1001.2101.3001.7020)（&&）的优先级高于逻辑或（||）



### 队列头部尾部问题

队列的头部保**存在队列中存放时间最长的元素，**尾部保存存放时间最短的元素。 新元素插入到队列的尾部，取出元素会返回队列头部的元素。 

先进先出，进的是尾部出的是头部

栈底元素最后一个弹出，栈顶元素第一个弹出。

另外remove()是删除头部元素，而removeLast()是删除最近添加的元素,如果强调的是同一处的添加与删除，可以使用addLast()与removeLast();

队列peek的时候是头部的元素（因为要出去了）

优先级队列中先出去的是peek

优先级队列poll出来的是最小的满足条件的元素

### ifelse尴尬之处

如果栈为空 然后直接与的话 if就直接为false
然后直接走下面的else if
但是如果你不与的话，判断完栈等于空，就不会走下面的else if
直接这一次的判断结束，区别就在这里

```java
if("..".equals(fileName) ) {
    //这里也容易出现问题，看了好一会，不能直接与，因为栈等于空直接走完一次
    //这里就是测试用例才测出来的
    //stack.pollLast();&& !stack.isEmpty()
    if(!stack.isEmpty()){
        stack.pollLast();
    }
}else if(!".".equals(fileName) && fileName.length() > 0) {
    stack.offerLast(fileName);
}
```



break的时候是break单个for循环